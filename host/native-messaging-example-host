#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a Tkinter dialog with incoming messages
# that also allows to send message back to the webapp.

import struct
import sys
import threading
import Queue
import subprocess
import json
import os
import re
from inspect import getsourcefile
from os.path import abspath

# import pipes

# try:
#   import Tkinter
#   import tkMessageBox
# except ImportError:
#   Tkinter = None

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
  import os, msvcrt
  msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

# Helper function that sends a message to the webapp.
def send_message(message):
   # Write message size.
  sys.stdout.write(struct.pack('I', len(message)))
  # Write the message itself.
  sys.stdout.write(message)
  sys.stdout.flush()

# Thread that reads messages from the webapp.
def read_thread_func(queue):
  message_number = 0
  while 1:
    # Read the message length (first 4 bytes).
    text_length_bytes = sys.stdin.read(4)

    if len(text_length_bytes) == 0:
      if queue:
        queue.put(None)
      sys.exit(0)

    # Unpack message length as 4 byte integer.
    text_length = struct.unpack('i', text_length_bytes)[0]

    # Read the text (JSON object) of the message.
    text = sys.stdin.read(text_length).decode('utf-8')

    if queue:
      queue.put(text)
    else:
      # In headless mode just send an echo message back.
      send_message('{"echo": %s}' % text)


class AxelThreadSpawn():
  def __init__(self, queue):
    self.queue = queue
    self.fileSizeRe = "File size:\s+([0-9]+)\s+.*"
    self.percentCompleteRe = "\[\s*([0-9]+)%\]"
    self.transferSpeedRe = "\[\s*([0-9]+\.[0-9]+).*\]"

    send_message('"INSIDE WINDOW INIT"')

    threading.Timer(1, self.processMessages).start()


  def processMessages(self):
    send_message('"NATIVE HOST HEARTBEAT: process msg loop"')

    while not self.queue.empty():
      send_message('"Q NOT EMPTY"')
      message = self.queue.get_nowait()

      if message == None:
        self.quit()
        return

      self.log("Received %s" % message)
      # self.onSend(message);
      message = json.loads(message)

      send_message('"FILE NAME"')
      send_message('"{0}"'.format(message['body']['fileName']));
      send_message('"AFTER FILE"')

      outopt = '{0}/{1}'.format('~/octjdl', message['body']['fileName'])
      outopt = os.path.expanduser(outopt)

      # dir_path = os.path.dirname(os.path.realpath(__file__))
      # self.log(dir_path)

      self.sendText('HOST URL RECVd')
      self.sendText(message['body']['url'])
      self.sendText(outopt)
      self.sendText('BEFORE DBG')
      # dbg=', '.join(['axel', '-o', outopt, '-n' + 4, message['body']['url']]), 
      dbg = 'axel -o {0} -n4 {1}'.format(outopt, message['body']['url'])
      self.sendText(dbg)
      self.sendText('AFTER DBG')

      # quotedUrl = pipes.quote(message['body']['url'])

      thread = threading.Thread(target=self.forkAxel, args=(outopt, message['body']['url']))
      thread.start()

    threading.Timer(1, self.processMessages).start()

  def sendJson(self, jsono):
    jsonstr = json.dumps(jsono)
    self.log('Sending %s' % jsonstr)
    try:
      send_message(jsonstr)
    except IOError:
      print 'failed to send message.'
      sys.exit(1)

  def sendText(self, msg):
    text = '{"text": "' + msg + '"}'
    self.log('Sending %s' % text)
    try:
      send_message(text)
    except IOError:
      print 'failed to send message.'
      sys.exit(1)

  def log(self, message):
    return

  def forkAxel(self, outpath, url):
    send_message('"AXEL FORKED {0} {1}"'.format(outpath, url))
    send_message('"THE CWD IS {0}"'.format(os.getcwd()))
    scriptdir = os.path.dirname(abspath(getsourcefile(lambda:0)))
    axel_util = '{0}/axel_util'.format(scriptdir)
    send_message('"SCRIPT LOC {0}"'.format(axel_util))

    proc = subprocess.Popen(
        [axel_util, outpath, url],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=False
    )
    self.monitorAxelChild(proc)
    # (out, err) = proc.communicate() # Communicate blocks
    self.sendText('AFTER PROC EXEC')
    # self.onSend(out)
    # self.log(err)

  def monitorAxelChild(self, child):
    self.sendText('MONITOR AXEL CHILD PROC OUTPUT:')

    programTerminated = False
    fileSizeStr = ''

    while not programTerminated:
      out = child.stdout.read(1024)
      uiUpdateMsg = {}

      if out == '' and child.poll() != None:
        self.sendText('***AXEL CHILD PROGRAM TERMINATED')
        programTerminated = True
      if out != '':
        # capture file size, ex: "File size: 387973120 bytes"
        if not fileSizeStr:
          filesizeg = re.search(self.fileSizeRe, out)
          if filesizeg:
            fileSizeStr = filesizeg.groups()[0]
            self.sendText('AXEL FILE SIZE FOUND: {0}'.format(fileSizeStr))

        # capture speed/%complete, ex: "[  0%]  .......... .......... .......... .......... ..........  [  48.0KB/s]"
        percentCompleteG = re.search(self.percentCompleteRe, out)
        transferSpeedG = re.search(self.transferSpeedRe, out)

        if fileSizeStr:
          uiUpdateMsg['filesize'] = fileSizeStr

        if percentCompleteG:
          uiUpdateMsg['percent'] = percentCompleteG.groups()[0]

        if transferSpeedG:
          uiUpdateMsg['transferSpeed'] = transferSpeedG.groups()[0]          

        self.sendJson(uiUpdateMsg)
        self.dbgLog(out)
        # err = child.stderr.read(1024)
        # self.dbgLog(err, 'dbgerrout')
        # self.onSend(out)

  def dbgLog(self, s, f='dbgout'):
    f = open(f, 'w')
    f.write(s)


def Main():
  # if not Tkinter:
  #   send_message('"Tkinter python module wasn\'t found. Running in headless ' +
  #                'mode. Please consider installing Tkinter."')
  #   read_thread_func(None)
  #   sys.exit(0)

  queue = Queue.Queue()
  send_message('"INSIDE MAIN FN"')
  ats = AxelThreadSpawn(queue)
  # main_window.master.title('Native Messaging Example')

  thread = threading.Thread(target=read_thread_func, args=(queue,))
  # thread.daemon = True
  thread.start()

  # main_window.mainloop()

  # sys.exit(0)


if __name__ == '__main__':
  Main()
